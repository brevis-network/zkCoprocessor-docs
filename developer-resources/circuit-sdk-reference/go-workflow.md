---
description: Brevis app building flow using Go SDK.
---

# Go Workflow

First, we need to install the Brevis Go SDK. To install, initialize a Go module project and run:

```
go get github.com/brevis-network/brevis-sdk
```

### Creating a `BrevisApp`

Your Integration with Brevis always starts with an `sdk.BrevisApp` instance that handles data access and interaction with Brevis's backend systems.

```go
import "github.com/brevis-network/brevis-sdk/sdk"
// ...
app := sdk.NewBrevisApp(1, "RPC_URL", "OUTPUT_DIR")
```

### Adding Source Data

Depending on your project, you may want to first query an indexer, such as Dune, an Ethereum node, or your own service, to acquire the raw data (such as transactions) according to your business logic. This part is **not** handled by the Brevis SDK.

{% hint style="warning" %}
**So why can't we just use the indexer data directly on chain?**

If you directly post the data from an indexer to your contract without any validity proofs, your users would be trusting the entity who posted this data to behave correctly. Brevis's core role is to replace this trust of data validity on one party with a ZK proof so no one can fabricate data and computation results.&#x20;
{% endhint %}

After you acquire the raw data, feed the data into the `app` instance as Receipt/Storage/Transaction data through:&#x20;

```go
// The AddXXX methods can be called multiple times and in a for loop to add more
app.AddReceipt(sdk.ReceiptData{...})
app.AddStorage(sdk.StorageData{...})
app.AddTransaction(sdk.TransactionData{...})
```

The data you add here will be available for use in your[ Application Circuit.](../../developer-guide/brevis-app-workflow/application-circuit.md)

Read more about [Source Data Types](brevis-app.md#query-types).

### Manually Compile & Prove <a href="#manually-compile-and-prove" id="manually-compile-and-prove"></a>

#### Compiling <a href="#compiling" id="compiling"></a>

Your circuit needs to be compiled before you can generate a proof with it. `sdk.Compile` automatically downloads the SRS for your circuit size and saves a `kzgsrs-bls12_377-xx` file to the provided `srsDir`, then it compiles the circuit and saves the compiled circuit, poving key, and verifying key to `outDir`.&#x20;

```go
compiledCircuit, pk, vk, err := sdk.Compile(appCircuit, outDir, srsDir)
```

The returned `compiledCircuit` object will be used in both setup and proving phases.

If your circuit has some custom inputs, you'll need to provide default values to them. [read more](https://docs.brevis.network/developer-resources/circuit-sdk-reference/peripheral-apis#compiling-and-setup)

The generated proving/verifying keys (pk and vk) uniquely identify your circuit with two properties:

* The proofs generated by your pk and circuit can be verified using your vk.
* Proofs not generated by your pk and circuit will fail to pass the verification using your vk.

#### Proof Generation <a href="#proof-generation" id="proof-generation"></a>

Proof generation is straight-forward. It uses the previously acquired `circuitInput`, `compiledCircuit`, `pk`, and your circuit definition.

```go
witness, _, err := sdk.NewFullWitness(appCircuitAssignment, circuitInput)
proof, err := sdk.Prove(compiledCircuit, pk, witness)
```

#### Submitting your Proof to Brevis <a href="#submitting-your-proof-to-brevis" id="submitting-your-proof-to-brevis"></a>

To submit your proof to Brevis, you first need to acquire a requestId and the fee amount from Brevis using `app.PrepareRequest`, then submit the proof using `app.SubmitProof`.

```go
calldata, requestId, feeValue, err := app.PrepareRequest(
    vk, witness, srcChainId, dstChainId, refundee, appContract, 0, gwproto.QueryOption_ZK_MODE.Enum(), "")
err = app.SubmitProof(proof)
```

PrepareRequest() must be called before SubmitProof()

Note that the above proof is not a "complete" proof in the sense that it doesn't prove the validity of the data source. When you submit your proof to Brevis, Brevis's provers will also generate additional data validity proofs that bridges this gap. Your application circuit proof will be aggregated together with these data validity proofs as a final proof which is submitted to the on-chain contract for verification. The data validity proof generation and the proof aggregation process are all handled internally by Brevis.
